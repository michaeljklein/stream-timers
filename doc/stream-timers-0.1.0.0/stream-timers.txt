-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some stream timers, and experiments with them
--   
--   Please see README.md
@package stream-timers
@version 0.1.0.0

module Data.Expire

-- | <a>expireSteps</a> is a global number of steps taken for expiration.
--   The idea is that the monad will throw some sort of exception, or
--   result in <a>Nothing</a>, when more than this many <a>Functor</a>,
--   <a>Applicative</a>, or <a>Monad</a> steps (actions) have been taken.
expireSteps :: Int

-- | Pure expiration, return <a>Nothing</a> to expire
newtype Expire a
Expire :: (Int, Maybe a) -> Expire a
[getExpire] :: Expire a -> (Int, Maybe a)

-- | <a>Expire</a> with <a>IO</a>, use a <a>Weak</a> reference outside of
--   the <a>Maybe</a> that <a>Expire</a> uses.
--   
--   Hopefully, <a>ExpireIO</a> will give near-instant expiration, not like
--   <a>Expire</a>, which seems to take around 1ns per action after
--   expiration.
newtype ExpireIO a
ExpireIO :: IO (Weak (IORef (Int, Maybe a))) -> ExpireIO a
[runExpireIO] :: ExpireIO a -> IO (Weak (IORef (Int, Maybe a)))

-- | Note: <a>stepExpire</a> will never halt if <a>Int</a> is negative, so
--   instead it throws an <a>error</a>
stepExpire :: Int -> a -> (Int, Maybe a)

-- | <a>stepExpire</a> for <a>Maybe</a>
stepExpireMaybe :: Int -> Maybe a -> (Int, Maybe a)

-- | Note: This is only safe if a <a>Weak</a> pointer has _already_ been
--   dereferenced
coerceWeak :: Weak a -> Weak b

-- | Deref an <a>ExpireIO</a>, only returning the value, or return
--   <a>Nothing</a>
getExpireIO :: ExpireIO a -> IO (Maybe a)

-- | Dereference an <a>ExpireIO</a>, or return <a>Nothing</a>
dumpExpireIO :: ExpireIO a -> IO (Maybe (Int, a))

-- | <a>finalize</a> an <a>ExpireIO</a>
killExpireIO :: ExpireIO a -> IO ()

-- | <a>Expire</a> that throws and <a>error</a> instead of returning
--   <a>Nothing</a>
newtype ExpireE a
ExpireE :: (Int, a) -> ExpireE a
[getExpireE] :: ExpireE a -> (Int, a)
instance GHC.Base.Functor Data.Expire.ExpireE
instance GHC.Show.Show a => GHC.Show.Show (Data.Expire.ExpireE a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Expire.ExpireE a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Expire.ExpireE a)
instance GHC.Base.Functor Data.Expire.Expire
instance GHC.Show.Show a => GHC.Show.Show (Data.Expire.Expire a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Expire.Expire a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Expire.Expire a)
instance GHC.Base.Functor Data.Expire.ExpireIO
instance GHC.Base.Applicative Data.Expire.ExpireIO
instance GHC.Base.Monad Data.Expire.ExpireIO
instance GHC.Base.Applicative Data.Expire.ExpireE
instance GHC.Base.Monad Data.Expire.ExpireE
instance GHC.Base.Applicative Data.Expire.Expire
instance GHC.Base.Monad Data.Expire.Expire

module Data.Timers

-- | <a>foldrOnce</a> applies a right fold, only once (for streams,
--   primarily).
foldrOnce :: (a -> b -> a) -> (a, [b]) -> (a, [b])

-- | <a>foldrTimes</a> applies <a>foldrOnce</a> a given number of times.
foldrTimes :: (a -> b -> a) -> (a, [b]) -> Int -> (a, [b])

-- | <a>foldlOnce</a> is the left-associative version of <a>foldrOnce</a>.
foldlOnce :: (a -> b -> b) -> ([a], b) -> ([a], b)

-- | See <a>foldlOnce</a>, <a>foldrTimes</a>.
foldlTimes :: (a -> b -> b) -> ([a], b) -> Int -> ([a], b)

-- | <a>foldrOnceM</a> generalizes <a>foldrOnceM</a> to general monads.
foldrOnceM :: Monad m => (a -> b -> a) -> (a, [b]) -> m (a, [b])

-- | See <a>foldrOnceM</a>, <a>foldrTimes</a>.
foldrTimesM :: Monad m => (t -> t1 -> t) -> (t, [t1]) -> Int -> m (t, [t1])

-- | See <a>foldrOnceM</a>, <a>foldlOnce</a>.
foldlOnceM :: Monad m => (t1 -> t -> t) -> ([t1], t) -> m ([t1], t)

-- | See <a>foldrTimesM</a>, <a>foldlOnceM</a>,
foldlTimesM :: Monad m => (t1 -> t -> t) -> ([t1], t) -> Int -> m ([t1], t)

-- | <a>nest</a> applies f to x, n times.
nest :: (b -> b) -> b -> Int -> b

-- | <a>nestM</a> generalizes <a>nest</a> to functions returning Monad
--   values.
nestM :: Monad m => (b -> m b) -> b -> Int -> m b

-- | <a>nestByM</a> generalizes <a>nestM</a> to numbers inside monads (for
--   example, <tt>mn</tt> could be (read.getLine)).
nestByM :: Monad m => (b -> m b) -> b -> m Int -> m b

-- | <a>nestMForever</a> is equivalent to `nestM f x Infinity`.
--   
--   <pre>
--   λ&gt; nestMForever (x -&gt; print x &gt;&gt; return x) (return 10 :: Expire Int)
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {ge^Cpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpireInterrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; nestMForever (x -&gt; print x &gt;&gt; return x) (return 10 :: ExpireE Int)
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   Ex^CE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}Interrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; dumpExpireIO = = print) &gt;&gt; return x) (return 10 :: ExpireIO Int)
--   J^Cust (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1Interrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; dumpExpireIO = = print &gt;&gt; killExpireIO x) &gt;&gt; return x) (return 10 :: ExpireIO Int)
--   Just^Cust (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10Interrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; dumpExpireIO = = print) &gt;&gt; return x) (return 10 :: ExpireIO Int)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Jus^Ct (1,10)
--   JusInterrupted.
--   
--   Real Mem: 157.4 MB
--   
--   See `stable_infinite_ExpireIO_loop_sample.txt` for a sample
--   </pre>
nestMForever :: Monad m => (b -> m b) -> b -> m b

-- | This function assumes that applying <tt>f</tt> too many times is fine,
--   it tries to apply <tt>f</tt> just enough times to hit EQ, then applies
--   <tt>g</tt> and repeats forever
nestByOrd :: (a -> Ordering) -> (a -> a) -> (a -> a) -> a -> a

-- | <a>switchByPred</a> returns `f x` if `p x` else `g x`.
switchByPred :: (t1 -> t) -> (t1 -> t) -> (t1 -> Bool) -> t1 -> t

-- | <a>switchOnM</a> is to <a>switchEveryN</a> as <a>nestByM</a> is to
--   <a>nestM</a>.
switchOnM :: (Monad m, Monad m1) => (b -> m1 b) -> (m1 b -> m b) -> m1 Int -> b -> m b

-- | <a>switchEveryN</a> applies f, n times, then g once, then repeats
--   forever.
switchEveryN :: Monad m => (b -> b) -> (b -> m b) -> Int -> b -> m b

-- | Seconds taken to be in <tt>[1..59]</tt>. This returns fElse of the
--   input if the clock time's minutes == minutes, otherwise <tt>f x</tt>.
--   Note that this function results in an infinite loop (which is why it
--   has a return type of <a>Void</a>).
switchEveryM :: Int -> Int -> (a -> IO a) -> (a -> IO a) -> a -> IO Void

-- | <a>fixPt</a> gives the fixed point of <tt>f</tt> on <tt>x</tt>.
--   Compare its type to that of <tt>fix</tt>:
--   
--   <pre>
--   fix :: (a -&gt; a) -&gt; a
--   </pre>
--   
--   This fixed-point stops at equality, e.g. <tt>1, 2, 3, 3, a.. -&gt; 1,
--   2, 3</tt>.
fixPt :: Eq a => (a -> a) -> a -> a

-- | Nest the function the given number of times, on the given value,
--   printing every iteration
--   
--   <pre>
--   f n x -&gt; (mapM_ print . take n . iterate f) x &gt;&gt; return (nest f n x)
--   </pre>
printEveryN :: Show b => (b -> b) -> Int -> b -> IO b

-- | Nest the function the given number of times, on the given value,
--   resulting in the given side-effect every iteration
--   
--   <pre>
--   s f n x -&gt; (mapM_ s . take n . iterate f) x &gt;&gt; return (nest f n x)
--   </pre>
sideEffectEveryN :: Monad m => (b -> m a) -> (b -> b) -> Int -> b -> m b

-- | The next step, <a>switchEvery''</a> forever <tt> <a>nestMForever</a>
--   switchEvery'' </tt>
switchEvery' :: (UTCTime, Integer, Int, IO t5 -> IO (IO t5), t5 -> IO (IO t5), IO t5) -> IO (UTCTime, Integer, Int, IO t5 -> IO (IO t5), t5 -> IO (IO t5), IO t5)

-- | This is a sketch of what a "log every so often, efficiently" function
--   could look like.
switchEvery'' :: (Integral t4, Integral t6) => (UTCTime, t6, t4, t7 -> IO t7, t5 -> IO t7, IO t5) -> IO (UTCTime, t6, Int, t7 -> IO t7, t5 -> IO t7, t7)

module Data.Timers.Example

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *

-- | Mystery function... (read the source)
gapless :: (Bits t, Num t) => t -> Bool

-- | Helper function to <a>gapless</a>
gapless' :: (Bits t, Num t) => t -> Bool

-- | Are <a>gapless</a> and <a>gapless'</a> equal?
gaplessEq :: (Bits a, Num a) => a -> Bool

-- | Number of <a>gapless</a> numbers in <tt>[1..n]</tt>
countGapless :: (Bits a, Enum a, Num a, Num b) => a -> b

-- | Number of <a>gapless'</a> numbers in <tt>[1..n]</tt>
countGapless' :: (Bits a, Enum a, Num a, Num b) => a -> b

-- | What it says on the box
nextGapless :: (Bits a, Num a) => a -> a

-- | Convert a list of lists to a list of Mathematica lists.
toMathematica :: Show a => [[a]] -> String

-- | One-liner to export gapless to mathematica:
--   
--   <pre>
--   concatMap (x-&gt;concat["{",show(head x),",",show(length x),"},"]).group . (x-&gt;zipWith(-)(tail x)x) . onlyGapless $ [1..100]
--   </pre>
--   
--   See <tt>only_gapless.md</tt>
onlyGapless :: (Bits t, Num t) => [t] -> [t]

-- | <a>onlyGapless</a>, differences, grouped, then converted to
--   Mathematica lists. {--}
onlyGaplessMathematica :: (Bits t, Num t, Show t) => [t] -> String

-- | First differences:
--   
--   <pre>
--   [x0, x1, x2, x3..] -&gt; [x1 - x0, x2 - x1, x3 - x2..]
--   </pre>
differences :: Num a => [a] -> [a]

-- | Should be equivalent to <a>differences</a>
differences_ :: Num a => [a] -> [a]

-- | Compare <a>differences</a> and <a>differences_</a>, specialized for
--   testing
prop_differences_ :: [Int] -> Bool

-- | Warning, this function is incomplete.
--   
--   <pre>
--   λ&gt; take 10 . getRuns . repeat $ 0 == _|_
--   λ&gt; take 10 . getRuns . repeat $ 1 == _|_
--   λ&gt; take 10 . getRuns . cycle $ [0] == _|_
--   λ&gt; take 10 . getRuns . cycle $ [1] == _|_
--   λ&gt; take 10 . getRuns . cycle $ [0,0] == _|_
--   λ&gt; take 10 . getRuns . cycle $ [0,1] == [1,1,1,1,1,1,1,1,1,1]
--   λ&gt; take 10 . getRuns . cycle $ [1,0] == [1,1,1,1,1,1,1,1,1,1]
--   λ&gt; take 10 . getRuns . cycle $ [1,1] == _|_
--   λ&gt; take 10 . getRuns . cycle $ [0,0,0] == _|_
--   λ&gt; take 10 . getRuns . cycle $ [0,0,1] == [2,2,2,2,2,2,2,2,2,2]
--   λ&gt; take 10 . getRuns . cycle $ [0,1,0] == [1,2,2,2,2,2,2,2,2,2]
--   λ&gt; take 10 . getRuns . cycle $ [0,1,1] == [1,1,1,1,1,1,1,1,1,1]
--   λ&gt; take 10 . getRuns . cycle $ [1,0,0] == [2,2,2,2,2,2,2,2,2,2]
--   λ&gt; take 10 . getRuns . cycle $ [1,0,1] == [1,1,1,1,1,1,1,1,1,1]
--   λ&gt; take 10 . getRuns . cycle $ [1,1,0] == [1,1,1,1,1,1,1,1,1,1]
--   λ&gt; take 10 . getRuns . cycle $ [1,1,1]
--   </pre>
--   
--   It's a fun autamata, note that it must be passed an infinite list, or
--   else it'll hit an exception. Even then, on some infinite lists, it'll
--   loop forever without printing (if it never hits 1's).
getRuns :: (Num a, Num b, Eq a) => [a] -> [b]

-- | A "match [] first" version of <a>getRuns</a>
getRunsA :: (Num a, Num b, Eq a) => [a] -> [b]

-- | A "match [] last" version of <a>getRuns</a>
getRunsB :: (Num a, Num b, Eq a) => [a] -> [b]

-- | Warning, this function is incomplete.
getRuns' :: (Num a, Num b, Eq a) => b -> [a] -> [b]

-- | A "match [] first" version of <a>getRuns'</a>
getRuns'A :: (Num a, Num b, Eq a) => b -> [a] -> [b]

-- | A "match [] last" version of <a>getRuns'</a>
getRuns'B :: (Num a, Num b, Eq a) => b -> [a] -> [b]

-- | Add a position to the <a>Map</a>
addPosition :: (Ord k0, Eq a, Num a) => (a, k0) -> Map k0 ((a, a, a, a, a), [(a, a, a, a, a)]) -> Map k0 ((a, a, a, a, a), [(a, a, a, a, a)])

-- | Abbrev. to make it easier to make the code generic
type Vec2 = ContVec 2

-- | Abbrev. to make it easier to make the code generic
type Vec4 = ContVec 4

-- | Abbrev. to make it easier to make the code generic
type Vec5 = ContVec 5

-- | A version of <a>addPosition</a> using <a>Vec5</a> instead of tuples
addPosition' :: (Ord k0, Eq a, Num a) => a -> k0 -> Map k0 (Vec5 a, [Vec5 a]) -> Map k0 (Vec5 a, [Vec5 a])

-- | The initial state of the stream
theStream :: (Enum a, Enum b, Num b, Bits b, Num a) => ([(a, b)], Map k v)

-- | Print the resulting <a>Map</a>
printMap :: (Show b, Show c) => (a1, Map b (a, [(c, c, c, c, c)])) -> IO ()

-- | Print the resulting <a>Map</a>, specialized to <a>Vec5</a>'s instead
--   of tuples
printMap' :: (Show a0, Show a2) => (a, Map a0 (a1, [Vec5 a2])) -> IO ()

-- | Print every nth value of the stream, specialized to the following
--   value (it's an infinite loop, so the return value simply encodes which
--   types the algorithm is specialized to).
printEveryNOfStream :: (Eq a, Bits k0, Num k0, Num a, Enum k0, Enum a, Ord k0, Show k0, Show a) => Int -> IO ([(a, k0)], Map k0 ((a, a, a, a, a), [(a, a, a, a, a)]))

-- | <a>printEveryNOfStream</a>, secialized to <a>ContVec</a>'s and using
--   <a>addPosition'</a>
printEveryNOfStream' :: (Eq a, Bits k0, Num k0, Num a, Enum k0, Enum a, Ord k0, Show (ContVec 5 a), Show k0, Show a) => Int -> IO ([(a, k0)], Map k0 (Vec5 a, [Vec5 a]))

-- | See <a>printEveryNOfStream</a>, except is uses <a>sideEffectEveryN</a>
--   instead of <a>printEveryN</a>
returnEveryN :: (Eq c, Show b, Show c, Ord b, Enum c, Enum b, Num c, Num b, Bits b) => Int -> IO ([(c, b)], Map b ((c, c, c, c, c), [(c, c, c, c, c)]))

-- | A version of <a>returnEveryN</a> using <a>addPosition'</a> and
--   <a>printMap'</a>
returnEveryN' :: (Eq a2, Enum a2, Num a2, Bits a1, Enum a1, Num a1, Ord a1, Show a2, Show a1) => Int -> IO ([(a2, a1)], Map a1 (Vec5 a2, [ContVec 5 a2]))
