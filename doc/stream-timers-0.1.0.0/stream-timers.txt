-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some stream timers, and experiments with them
--   
--   Please see README.md
@package stream-timers
@version 0.1.0.0

module Data.Expire

-- | <a>expireSteps</a> is a global number of steps taken for expiration.
--   The idea is that the monad will throw some sort of exception, or
--   result in <a>Nothing</a>, when more than this many <a>Functor</a>,
--   <a>Applicative</a>, or <a>Monad</a> steps (actions) have been taken.
expireSteps :: Int

-- | Pure expiration, return <a>Nothing</a> to expire
newtype Expire a
Expire :: (Int, Maybe a) -> Expire a
[getExpire] :: Expire a -> (Int, Maybe a)

-- | <a>Expire</a> with <a>IO</a>, use a <a>Weak</a> reference outside of
--   the <a>Maybe</a> that <a>Expire</a> uses.
--   
--   Hopefully, <a>ExpireIO</a> will give near-instant expiration, not like
--   <a>Expire</a>, which seems to take around 1ns per action after
--   expiration.
newtype ExpireIO a
ExpireIO :: IO (Weak (IORef (Int, Maybe a))) -> ExpireIO a
[runExpireIO] :: ExpireIO a -> IO (Weak (IORef (Int, Maybe a)))

-- | Note: <a>stepExpire</a> will never halt if <a>Int</a> is negative, so
--   instead it throws an <a>error</a>
stepExpire :: Int -> a -> (Int, Maybe a)

-- | <a>stepExpire</a> for <a>Maybe</a>
stepExpireMaybe :: Int -> Maybe a -> (Int, Maybe a)

-- | Note: This is only safe if a <a>Weak</a> pointer has _already_ been
--   dereferenced
coerceWeak :: Weak a -> Weak b

-- | Deref an <a>ExpireIO</a>, only returning the value, or return
--   <a>Nothing</a>
getExpireIO :: ExpireIO a -> IO (Maybe a)

-- | Dereference an <a>ExpireIO</a>, or return <a>Nothing</a>
dumpExpireIO :: ExpireIO a -> IO (Maybe (Int, a))

-- | <a>finalize</a> an <a>ExpireIO</a>
killExpireIO :: ExpireIO a -> IO ()

-- | <a>Expire</a> that throws and <a>error</a> instead of returning
--   <a>Nothing</a>
newtype ExpireE a
ExpireE :: (Int, a) -> ExpireE a
[getExpireE] :: ExpireE a -> (Int, a)
instance GHC.Base.Functor Data.Expire.ExpireE
instance GHC.Show.Show a => GHC.Show.Show (Data.Expire.ExpireE a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Expire.ExpireE a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Expire.ExpireE a)
instance GHC.Base.Functor Data.Expire.Expire
instance GHC.Show.Show a => GHC.Show.Show (Data.Expire.Expire a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Expire.Expire a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Expire.Expire a)
instance GHC.Base.Functor Data.Expire.ExpireIO
instance GHC.Base.Applicative Data.Expire.ExpireIO
instance GHC.Base.Monad Data.Expire.ExpireIO
instance GHC.Base.Applicative Data.Expire.ExpireE
instance GHC.Base.Monad Data.Expire.ExpireE
instance GHC.Base.Applicative Data.Expire.Expire
instance GHC.Base.Monad Data.Expire.Expire

module Timers

-- | <a>foldrOnce</a> applies a right fold, only once (for streams,
--   primarily).
foldrOnce :: (a -> b -> a) -> (a, [b]) -> (a, [b])

-- | <a>foldrTimes</a> applies <a>foldrOnce</a> a given number of times.
foldrTimes :: (a -> b -> a) -> (a, [b]) -> Int -> (a, [b])

-- | <a>foldlOnce</a> is the left-associative version of <a>foldrOnce</a>.
foldlOnce :: (a -> b -> b) -> ([a], b) -> ([a], b)

-- | See <a>foldlOnce</a>, <a>foldrTimes</a>.
foldlTimes :: (a -> b -> b) -> ([a], b) -> Int -> ([a], b)

-- | <a>foldrOnceM</a> generalizes <a>foldrOnceM</a> to general monads.
foldrOnceM :: Monad m => (a -> b -> a) -> (a, [b]) -> m (a, [b])

-- | See <a>foldrOnceM</a>, <a>foldrTimes</a>.
foldrTimesM :: Monad m => (t -> t1 -> t) -> (t, [t1]) -> Int -> m (t, [t1])

-- | See <a>foldrOnceM</a>, <a>foldlOnce</a>.
foldlOnceM :: Monad m => (t1 -> t -> t) -> ([t1], t) -> m ([t1], t)

-- | See <a>foldrTimesM</a>, <a>foldlOnceM</a>,
foldlTimesM :: Monad m => (t1 -> t -> t) -> ([t1], t) -> Int -> m ([t1], t)

-- | <a>nest</a> applies f to x, n times.
nest :: (b -> b) -> b -> Int -> b

-- | <a>nestM</a> generalizes <a>nest</a> to functions returning Monad
--   values.
nestM :: Monad m => (b -> m b) -> b -> Int -> m b

-- | <a>nestByM</a> generalizes <a>nestM</a> to numbers inside monads (for
--   example, <tt>mn</tt> could be (read.getLine)).
nestByM :: Monad m => (b -> m b) -> b -> m Int -> m b

-- | <a>nestMForever</a> is equivalent to `nestM f x Infinity`.
--   
--   <pre>
--   λ&gt; nestMForever (x -&gt; print x &gt;&gt; return x) (return 10 :: Expire Int)
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {ge^Cpire = (1,Just 10)}
--   Expire {getExpire = (1,Just 10)}
--   Expire {getExpireInterrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; nestMForever (x -&gt; print x &gt;&gt; return x) (return 10 :: ExpireE Int)
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   Ex^CE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}
--   ExpireE {getExpireE = (1,10)}Interrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; dumpExpireIO = = print) &gt;&gt; return x) (return 10 :: ExpireIO Int)
--   J^Cust (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1Interrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; dumpExpireIO = = print &gt;&gt; killExpireIO x) &gt;&gt; return x) (return 10 :: ExpireIO Int)
--   Just^Cust (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10Interrupted.
--   </pre>
--   
--   <pre>
--   λ&gt; dumpExpireIO = = print) &gt;&gt; return x) (return 10 :: ExpireIO Int)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Just (1,10)
--   Jus^Ct (1,10)
--   JusInterrupted.
--   
--   Real Mem: 157.4 MB
--   
--   See `stable_infinite_ExpireIO_loop_sample.txt` for a sample
--   </pre>
nestMForever :: Monad m => (b -> m b) -> b -> m b

-- | This function assumes that applying <tt>f</tt> too many times is fine,
--   it tries to apply <tt>f</tt> just enough times to hit EQ, then applies
--   <tt>g</tt> and repeats forever
nestByOrd :: (a -> Ordering) -> (a -> a) -> (a -> a) -> a -> a

-- | <a>switchByPred</a> returns `f x` if `p x` else `g x`.
switchByPred :: (t1 -> t) -> (t1 -> t) -> (t1 -> Bool) -> t1 -> t

-- | <a>switchOnM</a> is to <a>switchEveryN</a> as <a>nestByM</a> is to
--   <a>nestM</a>.
switchOnM :: (Monad m, Monad m1) => (b -> m1 b) -> (m1 b -> m b) -> m1 Int -> b -> m b

-- | <a>switchEveryN</a> applies f, n times, then g once, then repeats
--   forever.
switchEveryN :: Monad m => (b -> b) -> (b -> m b) -> Int -> b -> m b

-- | Seconds taken to be in <tt>[1..59]</tt>. This returns fElse of the
--   input if the clock time's minutes == minutes, otherwise <tt>f x</tt>.
--   Note that this function results in an infinite loop (which is why it
--   has a return type of <a>Void</a>).
switchEveryM :: Int -> Int -> (a -> IO a) -> (a -> IO a) -> a -> IO Void

-- | <a>fixPt</a> gives the fixed point of <tt>f</tt> on <tt>x</tt>.
--   Compare its type to that of <tt>fix</tt>:
--   
--   <pre>
--   fix :: (a -&gt; a) -&gt; a
--   </pre>
--   
--   This fixed-point stops at equality, e.g. <tt>1, 2, 3, 3, a.. -&gt; 1,
--   2, 3</tt>.
fixPt :: Eq a => (a -> a) -> a -> a

-- | Nest the function the given number of times, on the given value,
--   printing every iteration
--   
--   <pre>
--   f n x -&gt; (mapM_ print . take n . iterate f) x &gt;&gt; return (nest f n x)
--   </pre>
printEveryN :: Show b => (b -> b) -> Int -> b -> IO b

-- | Nest the function the given number of times, on the given value,
--   resulting in the given side-effect every iteration
--   
--   <pre>
--   s f n x -&gt; (mapM_ s . take n . iterate f) x &gt;&gt; return (nest f n x)
--   </pre>
sideEffectEveryN :: Monad m => (b -> m a) -> (b -> b) -> Int -> b -> m b

-- | The next step, <a>switchEvery''</a> forever <tt> <a>nestMForever</a>
--   switchEvery'' </tt>
switchEvery' :: (UTCTime, Integer, Int, IO t5 -> IO (IO t5), t5 -> IO (IO t5), IO t5) -> IO (UTCTime, Integer, Int, IO t5 -> IO (IO t5), t5 -> IO (IO t5), IO t5)

-- | This is a sketch of what a "log every so often, efficiently" function
--   could look like.
switchEvery'' :: (Integral t4, Integral t6) => (UTCTime, t6, t4, t7 -> IO t7, t5 -> IO t7, IO t5) -> IO (UTCTime, t6, Int, t7 -> IO t7, t5 -> IO t7, t7)

module Lib

-- | <a>CULLong</a>
type ULL = CULLong

-- | <a>Map</a> type alias
type Map = Map

-- | Mystery function... (read the source)
gapless :: ULL -> Bool

-- | Helper function to <a>gapless</a>
gapless' :: ULL -> Bool

-- | Are <a>gapless</a> and <a>gapless'</a> equal?
gaplessEq :: ULL -> Bool

-- | Number of <a>gapless</a> numbers in <tt>[1..n]</tt>
countGapless :: Num a => ULL -> a

-- | Number of <a>gapless'</a> numbers in <tt>[1..n]</tt>
countGapless' :: Num a => ULL -> a

-- | What it says on the box
nextGapless :: ULL -> ULL

-- | One-liner to export gapless to mathematica:
--   
--   <pre>
--   concatMap (x-&gt;concat["{",show(head x),",",show(length x),"},"]).group . (x-&gt;zipWith(-)(tail x)x) . onlyGapless $ [1..100]
--   </pre>
--   
--   See <tt>only_gapless.md</tt>
onlyGapless :: [ULL] -> [ULL]

-- | First differences:
--   
--   <pre>
--   [x0, x1, x2, x3..] -&gt; [x1 - x0, x2 - x1, x3 - x2..]
--   </pre>
differences :: Num a => [a] -> [a]

-- | Warning, this function is incomplete.
getRuns :: [ULL] -> [ULL]

-- | A "match [] first" version of <a>getRuns</a>
getRunsA :: [ULL] -> [ULL]

-- | A "match [] last" version of <a>getRuns</a>
getRunsB :: [ULL] -> [ULL]

-- | Warning, this function is incomplete.
getRuns' :: ULL -> [ULL] -> [ULL]

-- | A "match [] first" version of <a>getRuns'</a>
getRuns'A :: ULL -> [ULL] -> [ULL]

-- | A "match [] last" version of <a>getRuns'</a>
getRuns'B :: ULL -> [ULL] -> [ULL]
addPosition :: (ULL, ULL) -> Map ULL ((ULL, ULL, ULL, ULL, ULL), [(ULL, ULL, ULL, ULL, ULL)]) -> Map ULL ((ULL, ULL, ULL, ULL, ULL), [(ULL, ULL, ULL, ULL, ULL)])
theStream :: ([(ULL, ULL)], Map k a1)
printMap :: forall a1 a. (a1, Map ULL (a, [(ULL, ULL, ULL, ULL, ULL)])) -> IO ()
printEveryNOfStream :: Int -> IO ([(ULL, ULL)], Map ULL ((ULL, ULL, ULL, ULL, ULL), [(ULL, ULL, ULL, ULL, ULL)]))
returnEveryN :: Int -> IO ([(ULL, ULL)], Map ULL ((ULL, ULL, ULL, ULL, ULL), [(ULL, ULL, ULL, ULL, ULL)]))
